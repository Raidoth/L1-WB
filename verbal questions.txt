1.	Какой самый эффективный способ конкатенации строк?

    Strings.Builder{}

2.	Что такое интерфейсы, как они применяются в Go?

    Интерфейс — это набор методов, представляющих стандартное поведение для различных типов данных.
    С помощью интерфейсов можно организовывать разные группы методов, применяемых к разным объектам. 
    Таким образом, программа вместо фактических реализаций сможет опираться на более высокие абстракции (интерфейсы), 
    позволяя методам работать с различными объектами, реализующими один и тот же интерфейс. 

3.	Чем отличаются RWMutex от Mutex?

    RWMutex концептуально то же самое, что и Mutex: он защищает доступ к памяти.
    Тем не менее, RWMutex дает вам немного больше контроля над памятью. 
    Вы можете запросить блокировку для чтения, и в этом случае вам будет предоставлен доступ, если блокировка не удерживается для записи.

4.	Чем отличаются буферизированные и не буферизированные каналы?

    По умолчанию размер буфера равен нулю, в этом случае запись блокируется пока не появится читающий, 
    Если задать буфер больше нуля, то запись не блокируется - пока не заполнится буфер, 
    по заполнении буфера - запись блокируется пока не появится читающий и не освободит место в буфере для записи.

5.	Какой размер у структуры struct{}{}?

    0

6.	Есть ли в Go перегрузка методов или операторов?

    У методов и операторов нет перегрузки.

7.	В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

    random

8.	В чем разница make и new?

  Метод make () выделяет место в памяти только для типов slice, map и chan и инициализирует объект. 
  Его первый параметр - это тип, а второй параметр - параметр переменной длины, который возвращает сам тип.
  Для типа среза (среза) первый размер представляет длину среза, а второй размер представляет собой емкость среза. Если указан только один параметр размера, емкость среза равна его длине;
  Для типа карты (словаря) существует только один размер, который указывает, сколько места выделено для карты. Если этот параметр опущен, автоматически выделяется небольшое пространство (этот параметр обычно не требуется, поскольку карта автоматически расширяется);
  Для типа chan (pipe) существует только один размер, который представляет буфер канала, и отсутствие параметра означает отсутствие буфера.

  new(T) выделяет обнуленную память для нового элемента типа T и возвращает его адрес, 
  значение типа * T: он возвращает указатель на вновь выделенное нулевое значение типа T, готовое к использованию; 
  он применяется к таким типам значений, как массивы и структуры. это эквивалент & amp; T {}

9.	Сколько существует способов задать переменную типа slice или map?

3

var m map[int]int
m := make(map[int]int)
m := new(map[int]int)

10.	Что выведет данная программа и почему?

func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

Данная программа выведет 1,1
В функции update указатель отличается от указателя в main, из-за этого ничего не поменялось

11.	Что выведет данная программа и почему?

func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}

Данная программа выведет числа от 0 до 4 и будет fatal error, из-за того, что в анонимную функцию горутины передается не указатель на WaitGroup
Следовательно в ней он копируется и wg.Done() не будет выполнено на WaitGroup в main функции и из-за этого wg.Wait() никогда не дождется завершения

12.	Что выведет данная программа и почему?

func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}

Данная программа выведет 0, потому что происходит инициализация локальной переменной в блоке if-else и ее инкрементация
На переменную в функции main это никак не влияет, тк она находится выше по стеку

13.	Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}

Данная программа выведет [100 2 3 4 5], из за того что слайс является указателем на массив  в функцию передается слайс из main 
В функции изменяется первый элемент и проимходит попытка добавить новый элемент в слайс, но из-за того что capacity не хватает,
выделяется новый слайс, и в него уже добавляется 100

14.	Что выведет данная программа и почему?

func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}

Данная программа выведет [b b a][a a], поскольку длинна слайса в main равна 2
Когда в анонимной функции к слайсу добавляется строка, то слайс переалоцирует память, тк не хватает места на 3 элемент
Из-за этого указатель уже будет на другой слайс и изменение по индексам произойдут только в анонимной функции, а в main ничего не изменится